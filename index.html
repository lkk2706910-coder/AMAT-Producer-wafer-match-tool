<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wafer Match Tool v3 Web (Proportional Scale)</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 0; display: flex; flex-direction: column; height: 100vh; background-color: #f0f0f0; overflow: hidden; }
        #ctrl-panel { background-color: #fff; padding: 10px; display: flex; align-items: center; flex-wrap: wrap; border-bottom: 1px solid #ccc; gap: 8px; font-size: 14px; }
        select, input[type="number"], button { padding: 5px; border: 1px solid #ccc; border-radius: 4px; }
        button { background-color: #E3F2FD; font-weight: bold; cursor: pointer; }
        button:hover { background-color: #BBDEFB; }
        #canvas-container { flex-grow: 1; position: relative; background-color: white; margin: 10px; border: 1px solid #ddd; display: flex; justify-content: center; align-items: center; overflow: hidden; }
        #modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center; }
        #modal-content { background: white; padding: 10px; border-radius: 8px; position: relative; text-align: center; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
        #close-btn { position: absolute; top: 5px; right: 10px; font-size: 24px; cursor: pointer; color: #aaa; }
        #close-btn:hover { color: black; }
        #popup-title { margin: 5px 0 10px 0; font-weight: bold; font-size: 16px; }
    </style>
</head>
<body>

    <div id="ctrl-panel">
        <select id="mode"><option value="FI5.X">FI5.X</option><option value="FI6.4">FI6.4</option></select>
        <label>Cassette:</label><select id="cass"><option value="A">A</option><option value="B">B</option><option value="C">C</option><option value="D">D</option></select>
        <label>Side:</label><select id="side"><option value="S1">S1</option><option value="S2">S2</option></select>
        <label>Target:</label><select id="station"><option value="LL">LL</option><option value="CHA">CHA</option><option value="CHB">CHB</option><option value="CHC">CHC</option></select>
        <label>Offset:</label><input type="number" id="offset" value="0" style="width: 50px;">
        <button onclick="document.getElementById('file-input').click()">Upload Image</button>
        <input type="file" id="file-input" accept="image/*" style="display: none;" onchange="handleUpload(this)">
        <span style="color: #666; font-size: 12px; margin-left: 5px;">(or Ctrl+V to paste)</span>
    </div>

    <div id="canvas-container">
        <canvas id="mainCanvas"></canvas>
    </div>

    <div id="modal-overlay" onclick="closePopup(event)">
        <div id="modal-content" onclick="event.stopPropagation()">
            <div id="close-btn" onclick="closePopup(null)">&times;</div>
            <div id="popup-title">Zoom View</div>
            <canvas id="popupCanvas" width="550" height="550"></canvas>
        </div>
    </div>

<script>
    // ----------------- 1. Global Config -----------------
    const REF_W = 600, REF_H = 750, REF_WAFER_R = 45;
    // Zoom Factor (0.85 means 85% size)
    const ZOOM_FACTOR = 0.85; 

    const RAW_WAFER_POS = {
        "A2": [245, 55], "A1": [355, 55], "B1": [135, 165], "B2": [135, 275],
        "C2": [465, 165], "C1": [465, 275], "LL1": [200, 385], "LL2": [400, 385],
        "CS": [300, 515], "CA": [150, 670], "CB": [250, 670], "CC": [350, 670], "CD": [450, 670]
    };
    const RAW_MODULE_BOXES = {
        "CHA": [190, 0, 410, 110], "CHB": [80, 110, 190, 330], "CHC": [410, 110, 520, 330],
        "MF": [190, 110, 410, 330], "LL": [80, 330, 520, 440], "Cooling": [250, 440, 350, 590],
        "CassA": [100, 590, 200, 720], "CassB": [200, 590, 300, 720], "CassC": [300, 590, 400, 720], "CassD": [400, 590, 500, 720]
    };
    const RAW_LABEL_POS = {
        "CHA": [300, 20], "CHB": [135, 220], "CHC": [465, 220], "MF": [300, 220],
        "LL": [300, 350], "Cooling": [300, 460], "CassA": [150, 600], "CassB": [250, 600], "CassC": [350, 600], "CassD": [450, 600]
    };

    let originalImage = null;
    let clickRegions = [];

    function toRad(deg) { return deg * Math.PI / 180; }

    // ----------------- 2. Angle Logic -----------------
    function getNodeAngle(mode, nodeName, cassName, side, startAngle) {
        if (["CA", "CB", "CC", "CD"].includes(nodeName)) return startAngle % 360;
        
        let rules = {};
        if (mode === "FI5.X") {
            if (["A", "B"].includes(cassName)) {
                rules = (side === "S1") 
                    ? {"LL1": 210, "A1": 30, "B1": 300, "C1": 120, "CS": 0} 
                    : {"CS": 300, "LL2": 0, "A2": 180, "B2": 90, "C2": 270};
            } else {
                rules = (side === "S1")
                    ? {"CS": 30, "LL1": 0, "A1": 180, "B1": 90, "C1": 270}
                    : {"LL2": 150, "A2": 330, "B2": 240, "C2": 60, "CS": 0};
            }
        } else { // FI6.4
            if (["A", "B"].includes(cassName)) {
                rules = (side === "S1")
                    ? {"LL1": 195, "A1": 15, "B1": 285, "C1": 105, "CS": 0}
                    : {"CS": 255, "LL2": 345, "A2": 165, "B2": 75, "C2": 255};
            } else {
                rules = (side === "S1")
                    ? {"CS": 105, "LL1": 15, "A1": 195, "B1": 105, "C1": 285}
                    : {"LL2": 165, "A2": 345, "B2": 255, "C2": 75, "CS": 0};
            }
        }
        
        let ruleAngle = rules[nodeName] !== undefined ? rules[nodeName] : 0;
        return (ruleAngle + startAngle) % 360;
    }

    function getFullPath(cassName, side, station) {
        let path = [`C${cassName}`];
        if ((["A", "B"].includes(cassName) && side === "S2") || (["C", "D"].includes(cassName) && side === "S1")) {
            path.push("CS");
        }
        path.push(side === "S1" ? "LL1" : "LL2");
        if (station !== "LL") {
            const targetMap = {"CHA":"A", "CHB":"B", "CHC":"C"};
            let target = targetMap[station];
            if (target) path.push(`${target}${side === "S1" ? '1' : '2'}`);
        }
        return path;
    }

    // ----------------- 3. Drawing & Cropping -----------------
    function drawCircularWafer(ctx, img, x, y, r, displayAngle) {
        if (!img) return;
        const w = img.width, h = img.height;
        const cropSize = Math.min(w, h) * 0.92;
        const sx = (w - cropSize) / 2, sy = (h - cropSize) / 2;

        ctx.save();
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.clip();
        ctx.translate(x, y);
        ctx.rotate(toRad(displayAngle)); 
        ctx.drawImage(img, sx, sy, cropSize, cropSize, -r, -r, r * 2, r * 2);
        ctx.restore();

        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.strokeStyle = "black";
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    function drawLayout() {
        const canvas = document.getElementById('mainCanvas');
        const container = document.getElementById('canvas-container');
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        const W = canvas.width, H = canvas.height;
        const ctx = canvas.getContext('2d');
        if (W < 10) return;

        // ----------------- Core: Proportional Scaling -----------------
        const fitScale = Math.min(W / REF_W, H / REF_H) * ZOOM_FACTOR;
        const actualW = REF_W * fitScale;
        const actualH = REF_H * fitScale;
        const offsetX = (W - actualW) / 2;
        const offsetY = (H - actualH) / 2;

        const tx = (val) => val * fitScale + offsetX;
        const ty = (val) => val * fitScale + offsetY;
        
        const curR = REF_WAFER_R * fitScale;
        // --------------------------------------------------------------

        ctx.clearRect(0, 0, W, H);
        clickRegions = [];

        const mode = document.getElementById('mode').value;
        const selC = document.getElementById('cass').value;
        const selS = document.getElementById('side').value;
        const selSt = document.getElementById('station').value;
        const offsetVal = parseInt(document.getElementById('offset').value) || 0;

        ctx.lineWidth = 2;
        ctx.strokeStyle = "#0015D1";
        
        // Draw Modules
        for (const [name, box] of Object.entries(RAW_MODULE_BOXES)) {
            const rx1 = tx(box[0]);
            const ry1 = ty(box[1]);
            const rW = (box[2] - box[0]) * fitScale;
            const rH = (box[3] - box[1]) * fitScale;

            ctx.strokeRect(rx1, ry1, rW, rH);
            
            let lx, ly;
            if (RAW_LABEL_POS[name]) {
                lx = tx(RAW_LABEL_POS[name][0]);
                ly = ty(RAW_LABEL_POS[name][1]);
            } else {
                lx = rx1 + rW / 2;
                ly = ry1;
            }
            ctx.fillStyle = "#5C6BC0";
            ctx.font = `bold ${Math.max(10, Math.floor(9 * fitScale * 1.5))}px Arial`;
            ctx.textAlign = "center";
            ctx.fillText(name, lx, ly);
        }

        const fullPath = getFullPath(selC, selS, selSt);
        
        // Draw Wafers
        for (const [name, pos] of Object.entries(RAW_WAFER_POS)) {
            const cx = tx(pos[0]);
            const cy = ty(pos[1]);
            
            const angle = getNodeAngle(mode, name, selC, selS, offsetVal);
            const displayAngle = (180 + angle) % 360;
            const isInPath = fullPath.includes(name);

            clickRegions.push({ name: name, x: cx, y: cy, r: curR, angle: angle });

            ctx.beginPath();
            ctx.arc(cx, cy, curR, 0, Math.PI * 2);
            ctx.fillStyle = isInPath ? "#FFFFFF" : "#E0FFFF";
            ctx.fill();
            ctx.strokeStyle = "#888888";
            ctx.lineWidth = 1;
            ctx.stroke();

            if (isInPath && originalImage) {
                drawCircularWafer(ctx, originalImage, cx, cy, curR, displayAngle);
            } else {
                ctx.fillStyle = isInPath ? "black" : "#BBBBBB";
                ctx.font = `${Math.max(10, Math.floor(9 * fitScale * 1.5))}px Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(name, cx, cy);
            }

            const rad = toRad(90 + displayAngle);
            const nLen = 9 * fitScale, wOff = 4 * fitScale;
            const ex = cx + curR * Math.cos(rad);
            const ey = cy + curR * Math.sin(rad);
            const p1x = cx + (curR - nLen) * Math.cos(rad);
            const p1y = cy + (curR - nLen) * Math.sin(rad);
            const perpX = Math.sin(rad), perpY = -Math.cos(rad);

            ctx.beginPath();
            ctx.moveTo(p1x, p1y);
            ctx.lineTo(ex - wOff * perpX, ey - wOff * perpY);
            ctx.lineTo(ex + wOff * perpX, ey + wOff * perpY);
            ctx.closePath();
            ctx.fillStyle = "#F44336";
            ctx.fill();

            if (isInPath) {
                ctx.beginPath();
                ctx.arc(cx, cy, curR + 2, 0, Math.PI * 2);
                ctx.strokeStyle = "#FF5252";
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = "#D32F2F";
                ctx.font = `bold ${Math.max(10, Math.floor(10 * fitScale * 1.5))}px Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "bottom";
                ctx.fillText(`${angle}°`, cx, cy - curR - 5);
            }
        }
    }

    // ----------------- 4. Popup Logic -----------------
    function showPopup(nodeName, angle) {
        if (!originalImage) return;
        const modal = document.getElementById('modal-overlay');
        const ctx = document.getElementById('popupCanvas').getContext('2d');
        const cx = 275, cy = 275;
        
        modal.style.display = 'flex';
        
        let viewRotation = 0;
        if (["A1", "A2"].includes(nodeName)) {
            viewRotation = 180;
        } else if (["B1", "B2"].includes(nodeName)) {
            viewRotation = 270;
        } else if (["C1", "C2"].includes(nodeName)) {
            viewRotation = 90; 
        }

        document.getElementById('popup-title').innerText = `Station: ${nodeName} | Rotation: ${angle}° (View Rot: ${viewRotation === 270 ? -90 : viewRotation}°)`;
        ctx.clearRect(0, 0, 550, 550);
        
        let finalImgAngle = (180 + angle + viewRotation) % 360;
        drawCircularWafer(ctx, originalImage, cx, cy, 210, finalImgAngle);

        let targetKey = null;
        if (["LL1", "LL2"].includes(nodeName)) targetKey = "LL";
        else if (["A1", "A2"].includes(nodeName)) targetKey = "A";
        else if (["B1", "B2"].includes(nodeName)) targetKey = "B";
        else if (["C1", "C2"].includes(nodeName)) targetKey = "C";

        if (targetKey) {
            const configs = {
                "A": { dx: 0, dy: 250, w: 360, h: 25, rot: 0 },
                "B": { dx: 250, dy: 0, w: 25, h: 360, rot: 90 },
                "C": { dx: -250, dy: 0, w: 25, h: 360, rot: 90 },
                "LL": { dx: 0, dy: -250, w: 360, h: 25, rot: 0 }
            };
            const cfg = configs[targetKey];
            
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(toRad(viewRotation));

            ctx.fillStyle = "#3B9CFF";
            ctx.fillRect(cfg.dx - cfg.w/2, cfg.dy - cfg.h/2, cfg.w, cfg.h);
            
            ctx.translate(cfg.dx, cfg.dy);
            ctx.rotate(toRad(cfg.rot));

            // Vertical Flip
            ctx.scale(-1, -1); 
            
            ctx.fillStyle = "white";
            ctx.font = "bold 11px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("SLIT VALVE", 0, 0);
            
            ctx.restore();
        }
    }

    function closePopup(e) { document.getElementById('modal-overlay').style.display = 'none'; }
    function handleUpload(input) {
        if (input.files && input.files[0]) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() { originalImage = img; drawLayout(); };
                img.src = e.target.result;
            };
            reader.readAsDataURL(input.files[0]);
        }
    }
    window.addEventListener('paste', function(e) {
        const items = (e.clipboardData || e.originalEvent.clipboardData).items;
        for (let i = 0; i < items.length; i++) {
            if (items[i].type.indexOf('image') !== -1) {
                const blob = items[i].getAsFile();
                const reader = new FileReader();
                reader.onload = function(evt) {
                    const img = new Image();
                    img.onload = function() { originalImage = img; drawLayout(); };
                    img.src = evt.target.result;
                };
                reader.readAsDataURL(blob);
            }
        }
    });
    document.getElementById('mainCanvas').addEventListener('click', function(e) {
        const rect = this.getBoundingClientRect();
        const mx = e.clientX - rect.left, my = e.clientY - rect.top;
        for (const r of clickRegions) {
            if (Math.hypot(mx-r.x, my-r.y) <= r.r) { showPopup(r.name, r.angle); break; }
        }
    });
    const inputs = document.querySelectorAll('select, input[type="number"]');
    inputs.forEach(el => el.addEventListener('change', drawLayout));
    inputs.forEach(el => el.addEventListener('input', drawLayout));
    window.addEventListener('resize', drawLayout);
    window.onload = drawLayout;
</script>
</body>
</html>